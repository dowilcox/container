#!/bin/bash
# Container management tool for k3s deployments

set -eo pipefail

SCRIPT_NAME=$(basename "$0")

# Colors for output (only if stdout is a terminal)
if [ -t 1 ]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m'
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# Helper functions
print_error() {
    echo -e "${RED}Error:${NC} $1" >&2
}

print_success() {
    echo -e "${GREEN}$1${NC}"
}

print_info() {
    echo -e "${BLUE}$1${NC}"
}

print_warning() {
    echo -e "${YELLOW}$1${NC}"
}

# Find a deployment by name (case-insensitive partial match)
find_deployment() {
    local name="$1"
    kubectl get deployments -A --no-headers | grep -v 'kube-system' | awk -v name="$name" 'tolower($2) ~ tolower(name) {print $1, $2}' | head -1
}

# Get namespace and deployment from search result
parse_result() {
    local result="$1"
    NAMESPACE=$(echo "$result" | awk '{print $1}')
    DEPLOYMENT=$(echo "$result" | awk '{print $2}')
}

# Require a container name argument
require_name() {
    if [ -z "$1" ]; then
        print_error "Container name required"
        echo "Usage: $SCRIPT_NAME $COMMAND <name>"
        exit 1
    fi
}

# Find deployment or exit with error
find_or_exit() {
    local name="$1"
    local result
    result=$(find_deployment "$name")

    if [ -z "$result" ]; then
        print_error "No deployment found matching '$name'"
        exit 1
    fi

    parse_result "$result"
}

# Check if deployment uses hostNetwork
uses_host_network() {
    local result
    result=$(kubectl get deployment "$DEPLOYMENT" -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.hostNetwork}' 2>/dev/null)
    [ "$result" = "true" ]
}

# Get the selector for a deployment
get_selector() {
    local label
    label=$(kubectl get deployment "$DEPLOYMENT" -n "$NAMESPACE" -o jsonpath='{.spec.selector.matchLabels.app}' 2>/dev/null)
    if [ -n "$label" ]; then
        echo "app=$label"
    else
        echo "app=$DEPLOYMENT"
    fi
}

# Get the pod name for a deployment using its actual selector
get_pod() {
    local selector
    selector=$(get_selector)
    kubectl get pods -n "$NAMESPACE" -l "$selector" --no-headers 2>/dev/null | grep -v 'Terminating' | head -1 | awk '{print $1}'
}

# Commands
cmd_help() {
    cat << EOF
Container management tool for k3s deployments

Usage: $SCRIPT_NAME <command> [arguments]

Commands:
  list                      List all deployments
  status <name>             Show status and health of a container
  logs <name> [-f] [-p]     View container logs (-f follow, -p previous)
  shell <name>              Open a shell in the container
  describe <name>           Show detailed container information
  events <name>             Show recent events for the container

  start <name>              Start a stopped container (scale to 1)
  stop <name>               Stop a container (scale to 0)
  restart <name>            Restart a container
  scale <name> <replicas>   Scale container to N replicas

  build <name>              Build container image only
  update <name>             Build and deploy container (restart deployment)

  help                      Show this help message

Examples:
  $SCRIPT_NAME list
  $SCRIPT_NAME status jellyfin
  $SCRIPT_NAME logs openwebui -f
  $SCRIPT_NAME restart scrypted
  $SCRIPT_NAME scale jellyfin 2
  $SCRIPT_NAME update myapp
EOF
}

cmd_list() {
    echo "Deployments:"
    echo ""
    printf "  %b%-25s %-15s %-10s%b\n" "$BLUE" "NAME" "NAMESPACE" "READY" "$NC"
    echo "  --------------------------------------------------------"
    kubectl get deployments -A --no-headers | grep -v -E 'kube-system|local-path|svclb' | while read -r ns name ready uptodate available age; do
        printf "  %-25s %-15s %-10s\n" "$name" "$ns" "$ready"
    done
}

cmd_status() {
    require_name "$1"
    find_or_exit "$1"

    echo ""
    print_info "=== Deployment: $DEPLOYMENT (namespace: $NAMESPACE) ==="
    echo ""

    # Deployment status
    echo "Deployment Status:"
    kubectl get deployment "$DEPLOYMENT" -n "$NAMESPACE" -o wide
    echo ""

    # Pod status
    echo "Pod Status:"
    kubectl get pods -n "$NAMESPACE" -l "$(get_selector)" -o wide 2>/dev/null || \
        kubectl get pods -n "$NAMESPACE" | grep -i "$DEPLOYMENT" || \
        echo "  No pods found"
    echo ""

    # Recent events
    echo "Recent Events:"
    kubectl get events -n "$NAMESPACE" --field-selector involvedObject.name="$DEPLOYMENT" --sort-by='.lastTimestamp' 2>/dev/null | tail -5 || echo "  No events"
}

cmd_logs() {
    local name=""
    local flags=()

    # Parse arguments - name is first non-flag argument
    while [ $# -gt 0 ]; do
        case "$1" in
            -f|--follow)
                flags+=("-f")
                ;;
            -p|--previous)
                flags+=("--previous")
                ;;
            -*)
                print_error "Unknown flag: $1"
                exit 1
                ;;
            *)
                if [ -z "$name" ]; then
                    name="$1"
                fi
                ;;
        esac
        shift
    done

    require_name "$name"
    find_or_exit "$name"

    local pod
    pod=$(get_pod)

    if [ -z "$pod" ]; then
        print_error "No running pod found for $DEPLOYMENT"
        exit 1
    fi

    print_info "Showing logs for pod $pod..."
    kubectl logs "$pod" -n "$NAMESPACE" "${flags[@]}"
}

cmd_shell() {
    require_name "$1"
    find_or_exit "$1"

    local pod
    pod=$(get_pod)

    if [ -z "$pod" ]; then
        print_error "No running pod found for $DEPLOYMENT"
        exit 1
    fi

    print_info "Opening shell in pod $pod..."

    # Try common shells in order of preference
    kubectl exec -it "$pod" -n "$NAMESPACE" -- /bin/bash 2>/dev/null || \
    kubectl exec -it "$pod" -n "$NAMESPACE" -- /bin/sh 2>/dev/null || \
    kubectl exec -it "$pod" -n "$NAMESPACE" -- /bin/ash 2>/dev/null || \
    { print_error "Could not find a shell in the container"; exit 1; }
}

cmd_describe() {
    require_name "$1"
    find_or_exit "$1"

    print_info "=== Deployment ==="
    kubectl describe deployment "$DEPLOYMENT" -n "$NAMESPACE"

    echo ""
    print_info "=== Pods ==="
    local pod
    pod=$(get_pod)
    if [ -n "$pod" ]; then
        kubectl describe pod "$pod" -n "$NAMESPACE"
    else
        echo "No pods found"
    fi
}

cmd_events() {
    require_name "$1"
    find_or_exit "$1"

    print_info "Events for $DEPLOYMENT in namespace $NAMESPACE:"
    echo ""
    kubectl get events -n "$NAMESPACE" --sort-by='.lastTimestamp' | grep -i "$DEPLOYMENT" || echo "No events found"
}

cmd_start() {
    require_name "$1"
    find_or_exit "$1"

    print_info "Starting $DEPLOYMENT..."
    kubectl scale deployment/"$DEPLOYMENT" -n "$NAMESPACE" --replicas=1

    echo "Waiting for pod to be ready..."
    kubectl rollout status deployment/"$DEPLOYMENT" -n "$NAMESPACE" --timeout=120s

    print_success "Started $DEPLOYMENT"
}

cmd_stop() {
    require_name "$1"
    find_or_exit "$1"

    print_info "Stopping $DEPLOYMENT..."
    kubectl scale deployment/"$DEPLOYMENT" -n "$NAMESPACE" --replicas=0

    print_success "Stopped $DEPLOYMENT"
}

cmd_restart() {
    require_name "$1"
    find_or_exit "$1"

    print_info "Restarting $DEPLOYMENT..."

    # hostNetwork deployments can't do rolling restarts (port conflicts)
    # Use scale down/up instead
    if uses_host_network; then
        print_warning "hostNetwork detected, using scale down/up restart"
        local selector
        selector=$(get_selector)
        kubectl scale deployment/"$DEPLOYMENT" -n "$NAMESPACE" --replicas=0
        kubectl wait --for=delete pod -l "$selector" -n "$NAMESPACE" --timeout=60s 2>/dev/null || true
        kubectl scale deployment/"$DEPLOYMENT" -n "$NAMESPACE" --replicas=1
    else
        kubectl rollout restart deployment/"$DEPLOYMENT" -n "$NAMESPACE"
    fi

    echo "Waiting for rollout to complete..."
    kubectl rollout status deployment/"$DEPLOYMENT" -n "$NAMESPACE" --timeout=120s

    print_success "Restarted $DEPLOYMENT"
}

cmd_scale() {
    require_name "$1"
    local replicas="$2"

    if [ -z "$replicas" ]; then
        print_error "Replica count required"
        echo "Usage: $SCRIPT_NAME scale <name> <replicas>"
        exit 1
    fi

    if ! [[ "$replicas" =~ ^[0-9]+$ ]]; then
        print_error "Replicas must be a number"
        exit 1
    fi

    find_or_exit "$1"

    print_info "Scaling $DEPLOYMENT to $replicas replicas..."
    kubectl scale deployment/"$DEPLOYMENT" -n "$NAMESPACE" --replicas="$replicas"

    if [ "$replicas" -gt 0 ]; then
        echo "Waiting for rollout to complete..."
        kubectl rollout status deployment/"$DEPLOYMENT" -n "$NAMESPACE" --timeout=120s
    fi

    print_success "Scaled $DEPLOYMENT to $replicas replicas"
}

cmd_build() {
    require_name "$1"
    local name="$1"

    # Look for Dockerfile in common locations
    local build_dir=""
    local search_paths=(
        "$HOME/projects/$name"
        "$HOME/$name"
        "/opt/$name"
        "$HOME/src/$name"
    )

    for path in "${search_paths[@]}"; do
        if [ -f "$path/Dockerfile" ]; then
            build_dir="$path"
            break
        fi
    done

    if [ -z "$build_dir" ]; then
        print_error "Could not find Dockerfile for '$name'"
        echo "Searched in:"
        for path in "${search_paths[@]}"; do
            echo "  - $path"
        done
        echo ""
        echo "You can specify a path directly with:"
        echo "  cd /path/to/project && podman build -t localhost/$name:latest ."
        exit 1
    fi

    print_info "Building $name from $build_dir..."
    podman build -t "localhost/$name:latest" "$build_dir"

    print_info "Importing image into k3s..."
    podman save "localhost/$name:latest" | sudo k3s ctr images import -

    print_success "Built and imported localhost/$name:latest"
}

cmd_update() {
    require_name "$1"
    find_or_exit "$1"

    print_info "Updating $DEPLOYMENT in namespace $NAMESPACE..."

    # Get current image
    local image
    image=$(kubectl get deployment "$DEPLOYMENT" -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.containers[0].image}')
    echo "Image: $image"

    # Check if it's a local image that needs rebuilding
    if [[ "$image" == localhost/* ]]; then
        print_info "Local image detected, attempting to rebuild..."
        if ! cmd_build "$DEPLOYMENT"; then
            print_warning "Could not rebuild image, proceeding with restart only"
        fi
    fi

    # Restart deployment
    # hostNetwork deployments can't do rolling restarts (port conflicts)
    if uses_host_network; then
        print_warning "hostNetwork detected, using scale down/up restart"
        local selector
        selector=$(get_selector)
        kubectl scale deployment/"$DEPLOYMENT" -n "$NAMESPACE" --replicas=0
        kubectl wait --for=delete pod -l "$selector" -n "$NAMESPACE" --timeout=60s 2>/dev/null || true
        kubectl scale deployment/"$DEPLOYMENT" -n "$NAMESPACE" --replicas=1
    else
        kubectl rollout restart deployment/"$DEPLOYMENT" -n "$NAMESPACE"
    fi

    # Wait for rollout
    echo "Waiting for rollout to complete..."
    kubectl rollout status deployment/"$DEPLOYMENT" -n "$NAMESPACE" --timeout=120s

    print_success "Updated $DEPLOYMENT"
}

# Main command dispatch
COMMAND="${1:-help}"
shift 2>/dev/null || true

case "$COMMAND" in
    help|--help|-h)
        cmd_help
        ;;
    list|ls)
        cmd_list
        ;;
    status|st)
        cmd_status "$@"
        ;;
    logs|log)
        cmd_logs "$@"
        ;;
    shell|sh|exec)
        cmd_shell "$@"
        ;;
    describe|desc)
        cmd_describe "$@"
        ;;
    events|ev)
        cmd_events "$@"
        ;;
    start)
        cmd_start "$@"
        ;;
    stop)
        cmd_stop "$@"
        ;;
    restart)
        cmd_restart "$@"
        ;;
    scale)
        cmd_scale "$@"
        ;;
    build)
        cmd_build "$@"
        ;;
    update|up)
        cmd_update "$@"
        ;;
    *)
        print_error "Unknown command: $COMMAND"
        echo "Run '$SCRIPT_NAME help' for usage"
        exit 1
        ;;
esac
